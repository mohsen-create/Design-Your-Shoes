<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Advanced Realistic First-Person Car Game</title>
<style>
  body, html {
    margin: 0; height: 100%; overflow: hidden; background: #87ceeb;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  #loading {
    position: fixed; top:0; left:0; width:100%; height:100%;
    background: #111;
    color: #eee;
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    font-size: 24px; user-select: none; z-index: 1000;
  }
  #info {
    position: absolute; top: 15px; left: 15px;
    color: white; background: rgba(0,0,0,0.4); padding: 10px 14px;
    border-radius: 6px; user-select: none; z-index: 10;
    font-size: 16px;
  }
  #speed {
    font-weight: bold; font-size: 20px; letter-spacing: 1px;
  }
</style>
</head>
<body>
<div id="loading">Loading 3D car game... Please wait.</div>
<div id="info">Use WASD to drive, Mouse to look around.<br>Speed: <span id="speed">0</span> km/h</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/controls/PointerLockControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ammo.js@0.0.10/ammo.wasm.js"></script>

<script>
  let camera, scene, renderer, controls;
  let physicsWorld, tmpTrans;
  let rigidBodies = [];
  let clock = new THREE.Clock();

  let carBody, wheels = [];
  let vehicle, tuning;
  let engineForce = 0;
  let breakingForce = 0;
  let maxEngineForce = 2500;
  let maxBreakingForce = 200;

  let exhaustSound;
  let listener;
  let speedDisplay = document.getElementById('speed');

  let loadingScreen = document.getElementById('loading');

  Ammo().then(init);

  function init() {
    tmpTrans = new Ammo.btTransform();

    setupGraphics();
    setupPhysics();
    createEnvironment();
    createCar();
    setupControls();
    setupAudio();

    // Hide loading screen after short delay for demo smoothness
    setTimeout(() => {
      loadingScreen.style.display = 'none';
      // Auto lock pointer on start without user click (some browsers allow)
      try {
        controls.lock();
      } catch {}
      if (exhaustSound) exhaustSound.play();
    }, 1500);

    animate();
  }

  function setupGraphics() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 10);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    controls = new THREE.PointerLockControls(camera, document.body);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(20, 50, 20);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.left = -50;
    directionalLight.shadow.camera.right = 50;
    directionalLight.shadow.camera.top = 50;
    directionalLight.shadow.camera.bottom = -50;
    directionalLight.shadow.camera.near = 1;
    directionalLight.shadow.camera.far = 100;
    scene.add(directionalLight);

    window.addEventListener('resize', onWindowResize);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function setupPhysics() {
    let collisionConfiguration = new Ammo.btDefaultCollisionConfiguration(),
        dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration),
        overlappingPairCache = new Ammo.btDbvtBroadphase(),
        solver = new Ammo.btSequentialImpulseConstraintSolver();

    physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
    physicsWorld.setGravity(new Ammo.btVector3(0, -9.8, 0));
  }

  function createEnvironment() {
    // Ground
    let pos = {x:0, y:-0.6, z:0};
    let scale = {x:100, y:1, z:100};
    let quat = {x:0, y:0, z:0, w:1};
    let mass = 0;

    // Three.js ground - add texture
    const groundTexture = new THREE.TextureLoader().load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
    groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
    groundTexture.repeat.set(40,40);
    groundTexture.anisotropy = 16;
    let groundMaterial = new THREE.MeshPhongMaterial({map: groundTexture});

    let ground = new THREE.Mesh(new THREE.BoxGeometry(scale.x, scale.y, scale.z), groundMaterial);
    ground.position.set(pos.x, pos.y, pos.z);
    ground.receiveShadow = true;
    scene.add(ground);

    // Ammo.js ground
    let transform = new Ammo.btTransform();
    transform.setIdentity();
    transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
    transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
    let motionState = new Ammo.btDefaultMotionState(transform);

    let colShape = new Ammo.btBoxShape(new Ammo.btVector3(scale.x * 0.5, scale.y * 0.5, scale.z * 0.5));
    colShape.setMargin(0.05);

    let localInertia = new Ammo.btVector3(0, 0, 0);
    colShape.calculateLocalInertia(mass, localInertia);

    let rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, colShape, localInertia);
    let body = new Ammo.btRigidBody(rbInfo);
    physicsWorld.addRigidBody(body);
  }

  function createCar() {
    tuning = new Ammo.btVehicleTuning();
    let chassisWidth=2.2;
    let chassisHeight=0.6;
    let chassisLength=4.2;
    let massVehicle=900;

    // Three.js chassis - textured
    const bodyTexture = new THREE.TextureLoader().load('https://threejsfundamentals.org/threejs/resources/images/wall.jpg');
    let geometry = new THREE.BoxGeometry(chassisWidth, chassisHeight, chassisLength);
    let material = new THREE.MeshPhongMaterial({map: bodyTexture});
    carBody = new THREE.Mesh(geometry, material);
    carBody.castShadow = true;
    carBody.position.set(0, 2, 0);
    scene.add(carBody);

    // Ammo.js chassis shape
    let chassisShape = new Ammo.btBoxShape(new Ammo.btVector3(chassisWidth*0.5, chassisHeight*0.5, chassisLength*0.5));
    let transform = new Ammo.btTransform();
    transform.setIdentity();
    transform.setOrigin(new Ammo.btVector3(0, 2, 0));
    let motionState = new Ammo.btDefaultMotionState(transform);

    let localInertia = new Ammo.btVector3(0, 0, 0);
    chassisShape.calculateLocalInertia(massVehicle, localInertia);

    let rbInfo = new Ammo.btRigidBodyConstructionInfo(massVehicle, motionState, chassisShape, localInertia);
    let chassisBody = new Ammo.btRigidBody(rbInfo);
    chassisBody.setActivationState(4); // Disable deactivation

    physicsWorld.addRigidBody(chassisBody);

    // Vehicle
    let rayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld);
    vehicle = new Ammo.btRaycastVehicle(tuning, chassisBody, rayCaster);
    vehicle.setCoordinateSystem(0, 1, 2);
    physicsWorld.addAction(vehicle);

    // Wheels info
    let wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0);
    let wheelAxleCS = new Ammo.btVector3(-1, 0, 0);
    let suspensionRestLength = 0.6;
    let wheelRadius = 0.45;

    // Wheel positions relative to chassis
    let wheelPositions = [
      {x: chassisWidth*0.5 - 0.2, y: chassisHeight*0.5, z: chassisLength*0.5 - 0.4}, // front right
      {x: -chassisWidth*0.5 + 0.2, y: chassisHeight*0.5, z: chassisLength*0.5 - 0.4}, // front left
      {x: chassisWidth*0.5 - 0.2, y: chassisHeight*0.5, z: -chassisLength*0.5 + 0.4}, // rear right
      {x: -chassisWidth*0.5 + 0.2, y: chassisHeight*0.5, z: -chassisLength*0.5 + 0.4} // rear left
    ];

    // Add wheels with suspension params
    for(let i=0; i<4; i++) {
      let isFrontWheel = (i < 2);
      vehicle.addWheel(
        new Ammo.btVector3(wheelPositions[i].x, wheelPositions[i].y, wheelPositions[i].z),
        wheelDirectionCS0,
        wheelAxleCS,
        suspensionRestLength,
        wheelRadius,
        tuning,
        isFrontWheel
      );

      // Three.js wheel
      let wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, 0.4, 24);
      let wheelMaterial = new THREE.MeshPhongMaterial({color:0x222222});
      let wheelMesh = new THREE.Mesh(wheelGeometry, wheelMaterial);
      wheelMesh.rotation.z = Math.PI / 2;
      wheelMesh.castShadow = true;
      scene.add(wheelMesh);
      wheels.push(wheelMesh);
    }
  }

  function setupControls() {
    window.addEventListener('keydown', (e) => {
      switch(e.code) {
        case 'KeyW': engineForce = maxEngineForce; breakingForce = 0; break;
        case 'KeyS': engineForce = -maxEngineForce*0.7; breakingForce = 0; break;
        case 'KeyA': vehicle.setSteeringValue(0.5, 0); vehicle.setSteeringValue(0.5, 1); break;
        case 'KeyD': vehicle.setSteeringValue(-0.5, 0); vehicle.setSteeringValue(-0.5, 1); break;
      }
    });
    window.addEventListener('keyup', (e) => {
      switch(e.code) {
        case 'KeyW': engineForce = 0; breakingForce = maxBreakingForce; break;
        case 'KeyS': engineForce = 0; breakingForce = maxBreakingForce; break;
        case 'KeyA': vehicle.setSteeringValue(0, 0); vehicle.setSteeringValue(0, 1); break;
        case 'KeyD': vehicle.setSteeringValue(0, 0); vehicle.setSteeringValue(0, 1); break;
      }
    });
  }

  function setupAudio() {
    listener = new THREE.AudioListener();
    camera.add(listener);

    exhaustSound = new THREE.PositionalAudio(listener);
    const audioLoader = new THREE.AudioLoader();
    audioLoader.load('https://cdn.freesound.org/previews/66/66717_931655-lq.mp3', function(buffer) {
      exhaustSound.setBuffer(buffer);
      exhaustSound.setLoop(true);
      exhaustSound.setVolume(0.4);
      exhaustSound.setRefDistance(10);
      exhaustSound.play();
    });

    carBody.add(exhaustSound);
  }

  // Simple exhaust particle effect behind car
  let particleSystem;
  function createExhaustParticles() {
    const particleCount = 150;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const velocities = new Float32Array(particleCount * 3);

    for (let i=0; i<particleCount; i++) {
      positions[i*3] = 0;
      positions[i*3+1] = 0;
      positions[i*3+2] = 0;

      velocities[i*3] = (Math.random()-0.5)*0.1;
      velocities[i*3+1] = Math.random()*0.2 + 0.1;
      velocities[i*3+2] = (Math.random()-0.5)*0.1;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

    const material = new THREE.PointsMaterial({
      color: 0xdddddd,
      size: 0.1,
      transparent: true,
      opacity: 0.7,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);
  }

  function updateParticles(delta) {
    if (!particleSystem) return;
    const positions = particleSystem.geometry.attributes.position.array;
    const velocities = particleSystem.geometry.attributes.velocity.array;

    for (let i = 0; i < positions.length; i += 3) {
      velocities[i + 1] -= 0.005; // gravity effect on particles

      positions[i] += velocities[i];
      positions[i + 1] += velocities[i + 1];
      positions[i + 2] += velocities[i + 2];

      // Reset particle if too low or far
      if (positions[i + 1] < 0) {
        positions[i] = (Math.random() - 0.5) * 0.2;
        positions[i + 1] = 0;
        positions[i + 2] = (Math.random() - 0.5) * 0.2;

        velocities[i] = (Math.random() - 0.5) * 0.1;
        velocities[i + 1] = Math.random() * 0.2 + 0.1;
        velocities[i + 2] = (Math.random() - 0.5) * 0.1;
      }
    }

    particleSystem.geometry.attributes.position.needsUpdate = true;

    // Position behind the car
    let exhaustOffset = new THREE.Vector3(0, 0.2, -2);
    exhaustOffset.applyQuaternion(carBody.quaternion);
    let exhaustPos = carBody.position.clone().add(exhaustOffset);
    particleSystem.position.copy(exhaustPos);
  }

  function animate() {
    requestAnimationFrame(animate);

    let deltaTime = clock.getDelta();
    updatePhysics(deltaTime);
    updateParticles(deltaTime);
    renderer.render(scene, camera);
  }

  function updatePhysics(deltaTime) {
    vehicle.applyEngineForce(engineForce, 2);
    vehicle.applyEngineForce(engineForce, 3);
    vehicle.setBrake(breakingForce, 2);
    vehicle.setBrake(breakingForce, 3);

    physicsWorld.stepSimulation(deltaTime, 10);

    let tm = vehicle.getChassisWorldTransform();
    let p = tm.getOrigin();
    let q = tm.getRotation();
    carBody.position.set(p.x(), p.y(), p.z());
    carBody.quaternion.set(q.x(), q.y(), q.z(), q.w());

    let numWheels = vehicle.getNumWheels();
    for(let i=0; i<numWheels; i++) {
      vehicle.updateWheelTransform(i, true);
      let tm = vehicle.getWheelTransformWS(i);
      let pos = tm.getOrigin();
      let rot = tm.getRotation();
      wheels[i].position.set(pos.x(), pos.y(), pos.z());
      wheels[i].quaternion.set(rot.x(), rot.y(), rot.z(), rot.w());
    }

    // Update camera behind the car, first-person style
    const offset = new THREE.Vector3(0, 1.7, 0);
    const carFront = new THREE.Vector3(0, 0, 1);
    carFront.applyQuaternion(carBody.quaternion);

    camera.position.copy(carBody.position).add(offset);
    controls.getObject().position.copy(camera.position);

    // Rotate camera based on mouse
    // controls update automatically with pointer lock

    // Update speed display (convert m/s to km/h)
    let velocity = vehicle.getRigidBody().getLinearVelocity();
    let speed = velocity.length();
    speedDisplay.textContent = Math.round(speed * 3.6);
  }

  createExhaustParticles();
</script>
</body>
</html>
